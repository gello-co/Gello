/**
 * CSRF Protection Middleware using csrf-csrf
 * Generates and validates CSRF tokens for state-changing requests
 * Implements Double Submit Cookie Pattern for enhanced security
 */

import crypto from "node:crypto";
import { doubleCsrf } from "csrf-csrf";
import type { NextFunction, Request, Response } from "express";

// Initialize CSRF protection with Double Submit Cookie Pattern
const isProduction = process.env.NODE_ENV === "production";

// Get CSRF secret - required in production, generated in development
function getCsrfSecret(): string {
  const secret = process.env.CSRF_SECRET;

  if (isProduction) {
    if (!secret || secret.trim() === "") {
      throw new Error(
        "CSRF_SECRET environment variable is required in production. " +
          "Set a secure random 64+ character string in your environment variables.",
      );
    }
    return secret;
  }

  // Development: Generate random secret if not provided, with warning
  if (!secret || secret.trim() === "") {
    const generatedSecret = crypto.randomBytes(32).toString("hex");
    console.warn(
      "⚠️  WARNING: CSRF_SECRET not set. Using generated temporary secret.",
      "This secret will change on each restart. Set CSRF_SECRET in your environment for persistent sessions.",
    );
    return generatedSecret;
  }

  return secret;
}

const { doubleCsrfProtection, generateCsrfToken } = doubleCsrf({
  getSecret: getCsrfSecret,
  getSessionIdentifier: (req) => {
    // For cookie-based auth (Supabase), use a stable identifier
    // Use user ID if authenticated
    if (req.user?.id) {
      return req.user.id;
    }
    // For anonymous users, use a constant identifier
    // The Double Submit Cookie Pattern relies on cookie + token matching,
    // not on session-based secrets, so a constant is safe for anonymous users
    return "anonymous";
  },
  // Use __Host- prefix only in production (requires secure: true)
  cookieName: isProduction ? "__Host-csrf" : "csrf",
  cookieOptions: {
    httpOnly: true,
    sameSite: "lax",
    secure: isProduction,
    path: "/",
  },
  size: 64,
  ignoredMethods: ["GET", "HEAD", "OPTIONS"],
  getCsrfTokenFromRequest: (req) => {
    // Check X-CSRF-Token header first (for API calls)
    // Express normalizes headers to lowercase
    const headerToken =
      req.headers["x-csrf-token"] || req.headers["X-CSRF-Token"];
    if (headerToken && typeof headerToken === "string") {
      return headerToken;
    }
    // Check _csrf body field (for form submissions)
    if (req.body && req.body._csrf) {
      return req.body._csrf as string;
    }
    return null;
  },
});

export const csrfProtection = doubleCsrfProtection;

/**
 * Middleware to make CSRF token available to all views via res.locals
 */
export function csrfTokenToLocals(
  req: Request,
  res: Response,
  next: NextFunction,
): void {
  // Generate CSRF token and make it available to all views
  res.locals.csrfToken = generateCsrfToken(req, res);
  next();
}

/**
 * Endpoint handler to get CSRF token for client-side requests
 * Reuses token from csrfTokenToLocals if available to avoid double generation
 */
export function getCsrfToken(req: Request, res: Response): void {
  // If token was already generated by csrfTokenToLocals middleware, reuse it
  // This prevents generating two different tokens in the same request
  const token = res.locals.csrfToken || generateCsrfToken(req, res);
  res.json({ csrfToken: token });
}
